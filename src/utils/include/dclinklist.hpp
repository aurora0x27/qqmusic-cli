// double circular linked list
// used to generate play list
#include <stack>
#include <vector>
#include <stdlib.h>

template <typename T>
class dclinklist {
    public:
        dclinklist() = delete;
        dclinklist(T dat);
        dclinklist(std::vector<T> li);
        ~dclinklist();
        void goto_next_node();
        void goto_prev_node();
        T    get_curr_node_data();
        void insert_after_curr_node(T dat);
    private:
        struct node {
            T data;
            struct node* next;
            struct node* prev;
        };
        struct node* curr;
        // this stack is to store addresses generated by malloc
        std::stack<struct node*> mem_alloc_ptr;
};

template <typename T>
dclinklist<T>::dclinklist(T dat) {
    this->curr = (struct node*)malloc(sizeof(struct node));
    this->curr->data = dat;
    this->curr->next = this->curr;
    this->curr->prev = this->curr;
}

template <typename T>
dclinklist<T>::dclinklist(std::vector<T> li) {
    int count = li.size();
    this->curr = (struct node*)malloc(count * sizeof(struct node));
    mem_alloc_ptr.push(this->curr);
    for (int i = 0; i < count; ++i) {
        ((this->curr) + i)->data = li[i];
        ((this->curr) + i)->next = i == count - 1 ? this->curr : this->curr + i + 1;
        ((this->curr) + i)->prev = i == 0         ? this->curr : this->curr + i - 1;
    }
}

template <typename T>
dclinklist<T>::~dclinklist() {
    while (!mem_alloc_ptr.empty()) {
        struct node* tmp = mem_alloc_ptr.top();
        free(tmp);
        mem_alloc_ptr.pop();
    }
}

template <typename T>
void dclinklist<T>::goto_next_node() {
    this->curr = this->curr->next;
}

template <typename T>
void dclinklist<T>::goto_prev_node() {
    this->curr = this->curr->prev;
}

template <typename T>
void dclinklist<T>::insert_after_curr_node(T dat) {
    struct node* tmp = (struct node*)malloc(sizeof(struct node));
    mem_alloc_ptr.push(tmp);
    tmp->data = dat;
    tmp->next = this->curr->next;
    tmp->prev = this->curr;
    tmp->prev->next = tmp;
    tmp->next->prev = tmp;
}

template <typename T>
T dclinklist<T>::get_curr_node_data() {
    return this->curr->data;
}
